**JAVA**

\- **싱글톤 객체를 시작 시에 만드는 것이 아니라 처음으로 사용 될 때 만든다고 가정하면,**

**그 때 만약 두 스레드가 동시에 접근한다면 객체가 하나만 생성되는 것을 보장하는 방법?**

-> 자바 예약어 synchronize

-> lock 거는법 :  Lock객체

-> LazyHolder 기법 : 클래스 로더 되는 시점을 사용한 기법.

 

multithread 환경에서 일반적인 Signleton패턴을 사용하면 Thread-safe하지 못한 상황이 발생한다. Thread A가 인스턴스를 생성하기 전에 Thread B에게 제어권이 넘어가 버리면 Thread A가 인스턴스를 생성하지 않아 Thread B가 인스턴스를 인스턴스를 생성해 버리고 Thread A가 인스턴스를 생성하여 결과적으로 2개의 인스턴스를 생성되는 경우가 발생한다.

  이를 해결하기 위한 여러 가지 방법이 있는데 대표적인 처리 방법 중에서 가장 이상적인 기법은 크게 2가지 이다. 

첫째는 static 초기화를 이용한 singleton패턴 방법이 있다. 

**설명 추가**

둘째는 lazyHolder singleton 패턴이다. 

**설명 추가** 

참고로,  synchronized를 이용하여 처리하는 방법도 하나의 방법이지만, 불필요하게 lock이 걸리게 되어 비용 낭비가 크다라는 문제점이 존재한다고 한다. 

 

[참고 사이트]  

<https://javaplant.tistory.com/21>



**- List<Integer> sorting 하는 법.**

-> comparable 과 comparator

-> integer, string, file 는 기본적으로 Comparable이 구현되어있음.

 

Comparable - 기본 정렬기준을 구현하는데 사용한다.

Comparable 을 구현하고 있는 클래스들은 같은 타입의 인스턴스끼리 서로 비교할 수 있는 클래스들일 때 사용한다. 예를 들면, String, Integer, Date, File 등과 같은 것들이다. 

 

SoccerPlayer는 이름, 포지션, 나이 속성을 갖고 있고 각각 setter와 getter를 선언할 경우 sort를 하기 위해서는 객체내의 어떤 변수를 기준으로 정렬할지 정하지 않았기 때문에 일반적인 sort메서드로는 동작하지 않는다. 그래서 Comparable을 implements한 뒤 compareTo 메소드를 구현한다면 해결할 수 있다.



```java
public int compareTo(SoccerPlayer player) {	return name.compareTo(player.getName());}
```



public int compareTo(SoccerPlayer player) {	return name.compareTo(player.getName());}

Comparator - 기본 정렬기준 외에 다른 기준으로 정렬하고자할 때 사용한다.

Comparable을 implements 하지 않고도 오브젝트의 특정 변수를 기준으로 정렬하는 방법이 있다. 이 때 사용하는 방법이 바로 Comparator 이다. Comparator를 사용하면 정렬기준을 본인이 원하는대로 바꾸는 것이 가능하다. 



```java
ArrayList<SoccerPlayer> playerList = new ArrayList<SoccerPlayer>(); 
SoccerPlayer player1 = new SoccerPlayer("메시", "공격수", 23);
SoccerPlayer player2 = new SoccerPlayer("호날두", "공격수", 25); 

playerList.add(player1);
playerList.add(player2); 

Collections.sort(playerList, new Comparator<SoccerPlayer>(){ 	
    public int compare(SoccerPlayer p1, SoccerPlayer p2){				
        if(p1.getAge() > p2.getAge()) {			
            return 1;		
        } else if (p1.getAge() < p2.getAge()) {
            return -1;		} 
        else {			return 0; 		}	
    }
}); 
```



ArrayList<SoccerPlayer> playerList = new ArrayList<SoccerPlayer>(); SoccerPlayer player1 = new SoccerPlayer("메시", "공격수", 23);SoccerPlayer player2 = new SoccerPlayer("호날두", "공격수", 25); playerList.add(player1);playerList.add(player2); Collections.sort(playerList, new Comparator<SoccerPlayer>(){ 	public int compare(SoccerPlayer p1, SoccerPlayer p2){				if(p1.getAge() > p2.getAge()) {			return 1;		} else if (p1.getAge() < p2.getAge()) {			return -1;		} else {			return 0; 		}	}}); 

**- 자바 RA 버전 : 1.2**

Run Anyware ???? 자바 버전2를 의미 ..??

 

**- 자바 8 에서 변경된 것** 

자바8에서 추가된 대표적인 기능은 크게 람다표현식, 스트림이라고 말할 수 있다.



람다식은 식별자 없이 실행 가능한 함수 표현식이라고 말할 수 있다. 또한, 기존의 불필요한 코드를 줄이고 가독성을 향상시키는것에 목적을 두고 있습니다.

 

람다식을 사용하기 위해서는 일단 람다식으로 구현할 인터페이스가 필요하다.

이 인터페이스에는 조건이 하나있는데 한개의 추상메소드만 가지고 있어야 한다는 규칙이 존재한다.

이러한 추가적인 추상메소드 생성을 방지하기 위해서 @FunctionalInterface 어노테이션을 사용한다.

 

```java
public interface TestInterface{    
    public int plusAAndB(int a, int b);    
    public inst plusAll(int a); 
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
…
public static void main(String[] args){ 
	TestInterface t3 = (a, b) -> {return a+b}; 
}//에러 발생!!!
```



```java
@FunctionlInterfacepublic 
interface TestInterface{    
    public int plusAAndB(int a, int b);   
    //public inst plusAll(int a) ; 
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////

public static void main(String[] args){ 
    TestInterface t3 = (a, b) -> {return a+b}; 
} //에러 없애기~
```



[참고사이트]

<https://blog.hanumoka.net/2018/11/16/java-20181116-java-lambda/>

<https://jdm.kr/blog/181>

 

스트림을 사용하는 이유 : 복잡한 데이터 처리 질의를 표현하기 위해 Stream을 사용한다. 컬렉션을 사용할 경우, 처리 속도를 향상하기 위해서는 병렬 처리를 하도록 코드를 작성해야 되는데 이는 기술적으로도 어렵고 많은 에러가 발생한다.

 

이러한 단점들은 Java SE 8에서 stream을 통해 쿼리를 작성하듯 데이터를 명시적인 방법으로 처리할 수 있게 되었다. 멀티 스레드 관련 코드도 별도로 작성할 필요 없이 멀티코어를 지원할 수 있게 되었다.

 

스트림 API는 크게 스트림 생성, 중개 연산(스트림 변환), 종단 연산(스트림 사용) 단계로 구성 되어있다.

```java
  emps.stream().filter(x -> x.getSalary() > 100).count();      
//스트림 생성  .   중개 연산(스트림 변환)  .  종단 연산(스트림 사용) 
```



  emps.stream().filter(x -> x.getSalary() > 100).count();      스트림 생성  .   중개 연산(스트림 변환)  .  종단 연산(스트림 사용) 

스트림에서는 parallelStream() 메서드를 사용해서 멀티쓰레드 병렬 실행이 가능하다.



 ```java
int sum = numberList.parallelStream().filter(x -> x%2 ==0).sum(); 
//동시에 다수의 쓰레드가 filter와 sum을 실행, 각 쓰레드는 filter() -> sum()을 실행하고, 최종적으로 각 쓰레드의 sum()결과를 다시 sum()함 
 ```



[참고사이트]

<https://blog.naver.com/sipzirala/220985397393>

 

 

**- 자바 8 에서 Null 처리하는 객체 : Optional**

  자바가 “존재하지 않는 값”을 표현하기 위해서 null을 사용했다면, 이 함수형 언어(스칼라, 히스켈)들은 “존재할지 안 할지 모르는 값”을 표현할 수 있는 별개의 타입을 가지고 있습니다.

 

Java8은 이러한 함수형 언어의 접근 방식에서 영감을 받아 java.util.Optional<T>라는 새로운 클래스를 도입하였습니다.

 

Optional는 “존재할 수도 있지만 안 할 수도 있는 객체”, 즉, “null이 될 수도 있는 객체”을 감싸고 있는 일종의 래퍼 클래스입니다.

 

제네릭을 제공하기 때문에, 변수를 선언할 때 명기한 타입 파라미터에 따라서 감쌀 수 있는 객체의 타입이 결정됩니다.

Optional<Order> maybeOrder; // Order 타입의 객체를 감쌀 수 있는 Optional 타입의 변수 Optional<Member> optMember; // Member 타입의 객체를 감쌀 수 있는 Optional 타입의 변수 Optional<Address> address; // Address 타입의 객체를 감쌀 수 있는 Optional 타입의 변수

 

 

 

 

 



**- GC 에 대해 설명해주세요/GC 종류 무엇이 있나요?**

 

a라는 객체가 만들어져 메모리의 한부분을 점유하게 되고, 특정 메소드 호출한 후 수행이 완료되어 해당 객체가 더이상 필요없는 객체, 쓰레기가 됩니다. 이 쓰레기 객체를 효과적으로 처리하는 작업을 GC라고 합니다.

 

JVM의 메모리는 크게 클래스 영역, 자바 스택, 힙, 네이티브 메소드 스택의 4개 영역으로 나뉩니다. 가비지 콜렉터에서는 힙 메모리를 다루게 됩니다. 즉 자바콜렉터가 인식하고 할당하는 자바 메모리 영역은 힙 영역인 것입니다.

 

Young, Old, Perm 세 영역으로 나뉩니다. 이 중 Perm(Permanent) 영역은 거의 사용되지 않는 영역으로서 클래스와 메소드 정보와 같이 자바 언어 레벨에서 사용되지 않습니다. 

( Young (1. Eden, 2. Survivor 1, 3. Survivor 2), Old (4. 메모리) )

 

일단 메모리에 객체가 생성되면, Eden 영역에 객체가 지정됩니다.  Eden 영역에 데이터가 어느 정도 쌓이면, 이 영역에 있던 객체가 어디론가 옮겨지거나 삭제됩니다. 이 때 옮겨가는 위치가 survivor 영역입니다. 두개의 Survivor 영역 사이에 우선 순위가 있는 것은 아닙니다. 하지만, **이 두 개의 영역 중 한 영역은 반드시 비어 있어야 합니다.** 

 

**![img](https://lh6.googleusercontent.com/EuMYbWwk5LcRDuwdX1-5bbLbqWjL1dxWT2CjQ1TecbeOLe6UWMbVDsjItPQJoKXt8TqDLwAN1eCNvSGUd4MZvjZajRLKKWPlGiRJIaz0Mi7gjnynGNU0QwRGfutsm2ZyONzzMznE)**

Eden에서 survivor 둘 중 하나의 영역으로 할당 되고, 할당된 Survivor 영역이 차면, GC가 되면서 Eden 영역에 있는 객체와 꽉 찬 Survivor 영역에 있는 객체가 비어 있는 Survivor 영역으로 이동합니다. 그러다가 더 큰 객체가 생성되거나, 더 이상 Young 영역에 공간이 남지 않으면 객체들은 Old 영역으로 이동하게 됩니다.

 

마이너 GC: Young 영역에서 발생하는 GC

메이저 GC: Old 영역이나 Perm 영역에서 발생하는 GC

 

이 두가지 **GC가 어떻게 상호 작용하느냐에 따라서 GC 방식에 차이가 나며, 성능에도 영향을 줍니다.** GC가 발생하거나 객체가 각 영역에서 다른 영역으로 이동할 때 애플리케이션의 병목이 발생하면서 성능에 영향을 주게 됩니다. 

 

WAS나 자바 애플리케이션 수행시 옵션을 지정하여 선택

Serial Collector (이하 시리얼 콜렉터)

 

Parallel Collector (이하 병렬 콜렉터)

 

Parallel Compacting Collector (이하 병렬 컴팩팅 콜렉터)

 

Concurrent Mark-Sweep (CMS) Collector (이하 CMS 콜렉터)

 

***각 설명은 생략 사이트 참고**

 

[참고사이트]

https://12bme.tistory.com/57

 

 

**Spring Framework**

\- Springframework DI 란?

  DI를 설명하기 전에 IoC개념을 알아야합니다. IoC(Inversion of Control)는 프로그램의 흐림제어를 바뀌는 개념을 말합니다. 즉, 프레임워크(Framework) 기반의 개발에서는 프레임워크 자신이 흐름을 제어하는 주체가 되어, 필요 할 때마다 애플리케이션 코드를 호출하여 사용합니다. 

  즉, 팩토리 패턴의 장점을 더해 어떠한 것에도 의존하지 않는 형태가 되었습니다. 실행시점에 클래스간의 관계가 형성이 됩니다. 즉, 의존성이 삽입된다는 의미로 IoC를 DI라는 표현으로 사용합니다.

 

![img](https://lh3.googleusercontent.com/vStw3dQXw9ovXH4RfW6GRtJvfwcxv8gqAOSrI-tIy1v3hvR1z2jEshV-Mtz23JVullXx7nV51QculWY7FWs9wxZbmWDWmtRZuJdtlEmhxOfCaXXdK-VP8LxJ2FkaXy5bQCwoUW6c)

스프링에는 크게 

  **(1)XML로 작성된 Bean 정의 파일을 이용한 DI**

  **(2)어노테이션을 이용한 DI**

  **(3)JavaConfig에 의한 DI**

가 있습니다.

 

[참고사이트]

**https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/**

 

 

 

\- resultmap 안의 List 구현법.

 

\- MyBatis 에서 결과 조회할 때 resultMap과 Map 중에 무엇을 선호하였는가?

 

**DB**

\- OMR 관계형 데이터 베이스

\- Inner Join과 Outer Join의 차이

\- Explain 쿼리 써봤는지

\- 쿼리 성능이슈가 있었다면 어떻게 했는지

 